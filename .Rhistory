# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)
}
tanglerInfo
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
## Need capture output to save hash key to a readme file
hash.out<- tanglerInfo$hash
# rasterise tabular data
if (raster_object == TRUE){
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
# write revised coordinates to file
nm2<- paste0(getwd(), "/tanglerXY_",stub, "_", hash.out, ".rds")
saveRDS(object = rasterOuts, file = nm2)
return(rasterOuts)} else {
# write revised coordinates to file
nm2<- paste0(getwd(), "/tanglerXY_",stub, "_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}}
# Now entangle the raster object
tangler.out<- tangler(data = hunterCovariates_sub, tanglerInfo = tangles.out[[2]], raster_object = TRUE, stub = "myname")
if (raster_object == TRUE){
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xr<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] + r.num
return(xyData)
}
## Step 2 (shifting Y)
leap_Yr<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] + r.num
return(xyData)
}
## Step 3 (data rotation)
rotate_XYr<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)
}
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
## Need capture output to save hash key to a readme file
hash.out<- tanglerInfo$hash
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
head(tDat)
z=4
rasterFromXYZ(tDat[,c(1,2,z)])
plot(tDat[,1], tDat[,2])
?maxmemory
??maxmemory
?rasterFromXYZ
tDat[,c(1,2,z)]
rasterFromXYZ(tDat[,c(1,2,z)])
setOptions(maxmemory = 1e+09, chunksize=1e+08)
# R libraries
library(tangles);library(digest);library(raster);library(sp)
setOptions(maxmemory = 1e+09, chunksize=1e+08)
rasterOptions()
rasterFromXYZ(tDat[,c(1,2,z)])
nrow(tD)
nrow(tDat)
str(tempD)
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
if (raster_object == TRUE){
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
rasterFromXYZ(tDat[,c(1,2,z)])
# First entangle the point pattern
xyData<- as.matrix(HV_subsoilpH[,1:2])
tangles.out<- tangles(data = xyData, depth = 5, rasterdata = TRUE, raster_object = FALSE)
# Now entangle the raster object
tangler.out<- tangler(data = hunterCovariates_sub, tanglerInfo = tangles.out[[2]], raster_object = TRUE, stub = "myname")
tangler.out
tangles.out[[2]]
plot(tangler.out[[1]])
hunterCovariates_sub
tangler.out
# First entangle the point pattern
xyData<- as.matrix(HV_subsoilpH[,1:2])
tangles.out<- tangles(data = xyData, depth = 5, rasterdata = TRUE, raster_object = FALSE)
# Now entangle the raster object
tangler.out<- tangler(data = hunterCovariates_sub, tanglerInfo = tangles.out[[2]], raster_object = TRUE, stub = "myname")
tangles.out[[2]]
tangler.out
plot(tangler.out[[1]])
# Plotting
# original data
pHV_subsoilpH<- HV_subsoilpH
coordinates(pHV_subsoilpH)<- ~ X + Y
plot(hunterCovariates_sub[[1]])
plot(pHV_subsoilpH, add=T)
plot(hunterCovariates_sub[[1]])
plot(pHV_subsoilpH, add=T)
plot(hunterCovariates_sub[[1]])
plot(pHV_subsoilpH, add=T)
plot(hunterCovariates_sub[[1]], main="orginal data")
plot(pHV_subsoilpH, add=T)
pHV_subsoilpH
plot(hunterCovariates_sub[[1]], main="orginal data")
points(pHV_subsoilpH, add=T)
plot(pHV_subsoilpH)
plot(hunterCovariates_sub[[1]], main="orginal data", add=T)
plot(hunterCovariates_sub[[1]], main="orginal data")
plot(pHV_subsoilpH, add=T)
plot(hunterCovariates_sub[[1]], main="orginal data");plot(pHV_subsoilpH, add=T)
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
# tangled data
tPP<- as.data.frame(tangles.out[[1]])
coordinates(tPP)<- ~ X + Y
plot(tangler.out[[1]])
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
# Plotting
par(mfrow=c(1,2))
# original data
pHV_subsoilpH<- HV_subsoilpH
coordinates(pHV_subsoilpH)<- ~ X + Y
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
# tangled data
tPP<- as.data.frame(tangles.out[[1]])
coordinates(tPP)<- ~ X + Y
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
# Plotting
par(mfrow=c(1,2))
# original data
pHV_subsoilpH<- HV_subsoilpH
coordinates(pHV_subsoilpH)<- ~ X + Y
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
# tangled data
tPP<- as.data.frame(tangles.out[[1]])
coordinates(tPP)<- ~ X + Y
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
# Plotting
par(mfrow=c(1,2))
# original data
pHV_subsoilpH<- HV_subsoilpH
coordinates(pHV_subsoilpH)<- ~ X + Y
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
# tangled data
tPP<- as.data.frame(tangles.out[[1]])
coordinates(tPP)<- ~ X + Y
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
devtools::build_vignettes()
devtools::build_vignettes()
library(devtools)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
library(tangles)
load("Z:/Dropbox/2019/rmuddles/deIDent/data/detangler_data.rda")
load("Z:/Dropbox/2019/rmuddles/deIDent/data/detangler_data.rda")
load("Z:/Dropbox/2019/rmuddles/deIDent/data/detanglerData.rda")
load("Z:/Dropbox/2019/rmuddles/deIDent/data/detangler_data.rda")
getwd()
setwd("Z:/Dropbox/2019/rmuddles/deIDent/data/")
save(detangler_data, file="detangler_data.rda", compress='xz')
load("Z:/Dropbox/2019/rmuddles/deIDent/data/hunterCovariates_sub.rda")
save(hunterCovariates_sub, file="hunterCovariates_sub.rda", compress='xz')
load("Z:/Dropbox/2019/rmuddles/deIDent/data/HV_subsoilpH.rda")
save(HV_subsoilpH, file="HV_subsoilpH.rda", compress='xz')
library(tangles)
devtools::build_vignettes()
devtools::build_vignettes()
library(tangles)
library(tangles)
devtools::build_vignettes()
library(tangles)
library(tangles)
library(tangles)
path=NULL
# write revised coordinates to file
nm2<- paste0(path, "/tangledXY_raster", hash.out, ".rds")
source('C:/rdev/tangles/R/tangles.R')
source('C:/rdev/tangles/R/tangler.R')
source('C:/rdev/tangles/R/detangles.R')
library(digest);library(raster);library(sp)
# DATA SETS
# POINT PATTERN
data("HV_subsoilpH")
# RASTER OBJECT
data("hunterCovariates_sub")
getwd()
setwd<- "C:/Temp/"
xyData<- as.matrix(HV_subsoilpH[,1:2])
# DATA SETS
# POINT PATTERN
data("HV_subsoilpH")
# R libraries
library(tangles);library(digest);library(raster);library(sp)
# DATA SETS
# POINT PATTERN
data("HV_subsoilpH")
# RASTER OBJECT
data("hunterCovariates_sub")
source('C:/rdev/tangles/R/tangles.R')
source('C:/rdev/tangles/R/tangler.R')
source('C:/rdev/tangles/R/detangles.R')
xyData<- as.matrix(HV_subsoilpH[,1:2])
tangles.out<- tangles(data = xyData, depth = 3, rasterdata = FALSE, raster_object = FALSE, saveTangles = TRUE, path = getwd())
str(tangles.out)
getwd()
setwd<- "C:/Temp/"
getwd()
xyData<- as.matrix(HV_subsoilpH[,1:2])
xyData<- as.matrix(HV_subsoilpH[,1:2])
tangles.out<- tangles(data = xyData, depth = 3, rasterdata = FALSE, raster_object = FALSE, saveTangles = TRUE, path = "C:/Temp/")
str(tangles.out)
# First entangle the point pattern
xyData<- as.matrix(HV_subsoilpH[,1:2])
tangles.out<- tangles(data = xyData, depth = 5, rasterdata = TRUE, raster_object = FALSE, saveTangles = TRUE, path = "C:/Temp/")
# Now entangle the raster object
tangler.out<- tangler(data = hunterCovariates_sub, tanglerInfo = tangles.out[[2]], raster_object = TRUE, stub = "myname", saveTangles = TRUE, path = "C:/Temp/")
# Plotting
par(mfrow=c(1,2))
# original data
pHV_subsoilpH<- HV_subsoilpH
coordinates(pHV_subsoilpH)<- ~ X + Y
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
# tangled data
tPP<- as.data.frame(tangles.out[[1]])
coordinates(tPP)<- ~ X + Y
plot(tangler.out[[1]], main="tangled data");plot(tPP, add=T)
plot(hunterCovariates_sub[[1]], main="orginal data"); plot(pHV_subsoilpH, add=T)
library(tangles)
library(tangles)
library(devtools)
build_vignettes()
install.packages("digest")
install.packages("digest")
remove.packages("digest")
install.packages("digest")
build_vignettes()
library(devtools)
build_vignettes()
library(tangles)
rmarkdown::render(
input      = "vignettes/deidentification.Rmd",
output_dir = "inst/doc/",                    # folder you want it in
output_file= "deidentification.html"              # optional—defaults to your_doc.html
)
rmarkdown::render(
input      = "vignettes/deidentification.Rmd",
output_dir = "inst/doc/",                    # folder you want it in
output_file= "deidentification.html"              # optional—defaults to your_doc.html
)
packages <- tools::CRAN_package_db()
length(packages$Package)
data(detangler_data)
summary(detangler_data)
detangler_data
tempdir()
rmarkdown::render(
input      = "vignettes/deidentification.Rmd",
output_dir = "inst/doc/",                    # folder you want it in
output_file= "deidentification.html"              # optional—defaults to your_doc.html
)
rmarkdown::render(
input      = "vignettes/deidentification.Rmd",
output_dir = "inst/doc/",                    # folder you want it in
output_file= "deidentification.html"              # optional—defaults to your_doc.html
)
library(hexSticker)
install.packages("hexSticker")
library(hexSticker)
library(ggplot2)
# Example ggplot to act as background/logo
p <- ggplot(data.frame(x = c(0, 1)), aes(x)) +
stat_function(fun = function(x) exp(-((x - 0.5)^2) / 0.01), color = "blue", size = 1.2) +  # bell
stat_function(fun = function(x) 1 / (1 + exp(-10 * (x - 0.5))), color = "green", size = 1.2) +  # sigmoid
stat_function(fun = function(x) pmax(0, 1 - abs(x - 0.5) * 2), color = "purple", size = 1.2) +  # triangle
theme_void()
# Create the hex sticker
sticker(p,
package = "maptility",
p_size = 20,
p_color = "white",
p_family = "sans",
s_x = 1,
s_y = 0.8,
s_width = 1.4,
s_height = 1.4,
h_fill = "#325c48",  # background
h_color = "#FFFFFF",  # border
url = "github.com/brendo1001/maptility",
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png")
getwd()
library(hexSticker)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",  # path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",
subplot = F,# path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",
subplot = F,# path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
library(hexSticker)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",
subplot = F,# path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
library(hexSticker)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",
subplot = F,# path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
library(hexSticker)
# Create the hex sticker using your custom image
sticker(
image = "/home/brendo1001/Downloads/maptility_clean_raster_logo.png",
subplot = F,# path to the image
package = "maptility",                # package name
p_size = 20,                          # font size
p_color = "white",                    # font color
p_family = "sans",
s_x = 1, s_y = 0.8,                   # image position
s_width = 1.4, s_height = 1.4,        # image size
h_fill = "#2f4f2f",                   # background fill (DarkGreen-like)
h_color = "#ffffff",                 # border color
url = "github.com/brendo1001/maptility", # optional URL at bottom
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"   # output file name
library(hexSticker)
library(hexSticker)
library(magick)
library(grid)
# Read your PNG as a rasterGrob object
img_path <- "/home/brendo1001/Downloads/maptility_clean_raster_logo.png"
img <- image_read(img_path)
grob_img <- rasterGrob(as.raster(img), interpolate = TRUE)
# Now create the sticker using `subplot = grob_img`
sticker(
subplot = grob_img,
package = "maptility",
p_size = 20,
p_color = "white",
p_family = "sans",
s_x = 1, s_y = 0.8,
s_width = 1.4, s_height = 1.4,
h_fill = "#2f4f2f",
h_color = "#ffffff",
url = "github.com/brendo1001/maptility",
u_size = 4,
u_color = "white",
filename = "maptility_sticker.png"
)
