deg<- sample(1:359,1, replace = F)} # choose a random orientation
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(list(xyData,origin.point,deg))
}
## END Step 3 (data rotation)
########################################## END internalised step functions
## randomise the sequence of steps with defined depth
step.random<- sample(1:3, depth, replace = T)
## cycle through the step sequence
s3.cnt<- 1
seq.mat<- matrix(NA, nrow = depth, ncol = 6)
for (i in 1:depth){
seq.step<- step.random[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_X(xyData = xyData)
# save outputs
xyData<- step1.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step1.out[[2]]}
# if step 2
if(seq.step == 2){
step2.out<- leap_Y(xyData = xyData)
# save outputs
xyData<- step2.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step2.out[[2]]}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XY(xyData = xyData)
# save outputs
xyData<- step3.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,3:4]<- step3.out[[2]]
seq.mat[i,5]<- step3.out[[3]]
seq.mat[i,6]<- s3.cnt
s3.cnt<- s3.cnt + 1}
}
seq.dat<- as.data.frame(seq.mat)
names(seq.dat)<- c("step", "leap_dist", "origin_X", "origin_Y", "degree", "s3_count")
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# generate a hash
hash.out<- digest(seq.dat ,"sha256") # first try
deTangler<- list(hash = hash.out, step_sequence= step.random, unpicker= seq.dat)
# write de-tangler to file
nm1<- paste0(getwd(), "/detangler_", hash.out, ".rds")
saveRDS(object = deTangler, file = nm1)
# rasterise tabular data
if (raster_object == TRUE){
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
# write revised coordinates to file
nm2<- paste0(getwd(), "/tangledXY_raster", hash.out, ".rds")
saveRDS(object = rasterOuts, file = nm2)
return(list(rasterOuts, deTangler))
} else {
# write revised coordinates to file
nm2<- paste0(getwd(), "/tangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(list(xyData, deTangler))}}
## test it out
## test it out with point data
# tangles
setwd("/home/malone/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(data = xyData, depth = 5, rasterdata = FALSE, raster_object = FALSE)
tangles.out
str(tangles.out)
# tangler
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out
detangler.dat<- readRDS("detangler_1465351c42949cc8db6d6d3e3f15e65a39211560207d4c12607aaafe7dfa8f1b.rds")
str(detangler.dat)
plot(xyData)
tangler<- function(data=NULL, tanglerInfo = NULL, raster_object = FALSE, stub = NULL){
if (raster_object == TRUE){
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xr<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] + r.num
return(xyData)
}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yr<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] + r.num
return(xyData)
}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYr<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)
}
## END Step 3 (data rotation)
########################################## END internalised step functions
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
## Need capture output to save hash key to a readme file
hash.out<- tanglerInfo$hash
# rasterise tabular data
if (raster_object == TRUE){
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
# write revised coordinates to file
nm2<- paste0(getwd(), "/tanglerXY_",stub, "_", hash.out, ".rds")
saveRDS(object = rasterOuts, file = nm2)
return(rasterOuts)} else {
# write revised coordinates to file
nm2<- paste0(getwd(), "/tanglerXY_",stub, "_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}}
tangled.origi<- tangler(data = xyData, tanglerInfo = detangler.dat, raster_object = FALSE, stub = "hv1")
head(tangled.origi)
str(tangles.out)
head(tangles.out[[1]])
head(tangled.origi)
## test it out with raster data
library(raster)
data("hunterCovariates_sub")
str(hunterCovariates_sub)
raster_object<- hunterCovariates_sub
tangles.out<- tangles(data = hunterCovariates_sub, depth = 10, rasterdata = TRUE, raster_object = TRUE)
tangles.out
str(tangles.out)
#tangler
# tangler
data("hunterCovariates_sub")
str(hunterCovariates_sub)
str(tangles.out)
detangler.dat<- readRDS("detangler_77f23ff80a5320acda37bd03085f9e91dfadce3a66ce955928cba757a1d17964.rds")
str(detangler.dat)
tangled.origi<- tangler(data = hunterCovariates_sub, tanglerInfo = detangler.dat, raster_object = TRUE, stub = "hv1")
head(tangled.origi)
str(tangled.origi)
tangled.origi
plot(tangled.origi[[1]])
## Tanagle points then rasters
plot(hunterCovariates_sub[[1]])
plot(xyData,add=T)
plotxydat<- xyData
coordinates(plotxydat)<- ~ X + Y
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
## Tanagle points then rasters
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
# tangle the points
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(data = xyData, depth = 5, rasterdata = TRUE, raster_object = FALSE)
tangles.out
# tangle raster data based on tangled points
data("hunterCovariates_sub")
str(hunterCovariates_sub)
tangles.out
detangler.dat<- readRDS("detangler_184aa7e5987f7024835bab0290e7e70f4390565e6226111a0ff236110e626a6d.rds")
str(detangler.dat)
tangled.origi<- tangler(data = hunterCovariates_sub, tanglerInfo = detangler.dat, raster_object = TRUE, stub = "hv1")
tangled.origi
plot(tangled.origi[[1]])
# overlay tangle points
tp<- as.data.frame(tangles.out[[1]])
coordinates(tp)<- ~ X + Y
plot(tp, add=T)
## Tangle points then rasters
# plot original points
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
plot(tangled.origi[[1]])
plot(tp, add=T)
## Tangle points then rasters
# plot original points
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
detangles<- function(data=NULL, tanglerInfo=NULL, raster_object = FALSE){
if (raster_object == TRUE){
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
## Need capture output to save hash key to a readme file
# rasterise tabular data
if (raster_object == TRUE){
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_raster",stub, "_", hash.out, ".rds")
saveRDS(object = rasterOuts, file = nm2)
return(rasterOuts)} else {
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_",stub, "_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}}
## Tangle points then rasters
# plot original points
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
# tangle the points
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(data = xyData, depth = 15, rasterdata = TRUE, raster_object = FALSE)
tangles.out
# tangle raster data based on tangled points
data("hunterCovariates_sub")
str(hunterCovariates_sub)
detangler.dat<- readRDS("detangler_184aa7e5987f7024835bab0290e7e70f4390565e6226111a0ff236110e626a6d.rds")
str(detangler.dat)
tangles.out
detangler.dat<- readRDS("detangler_5f47b108227d1b405b88b70a4abbcfe25c6563f8e4801ef7f5fae10d776143e8.rds")
str(detangler.dat)
tangled.origi<- tangler(data = hunterCovariates_sub, tanglerInfo = detangler.dat, raster_object = TRUE, stub = "hv1")
tangled.origi
plot(tangled.origi[[1]])
# overlay tangle points
tp<- as.data.frame(tangles.out[[1]])
coordinates(tp)<- ~ X + Y
plot(tp, add=T)
tangles.out[[1]]
point_detang<- detangles(data=xyData, tanglerInfo=detangler.dat, raster_object = FALSE)
detangles<- function(data=NULL, tanglerInfo=NULL, raster_object = FALSE, stub = NULL){
if (raster_object == TRUE){
tempD <- data.frame(cellNos = seq(1:ncell(data)))
vals <- as.data.frame(getValues(data))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(data, cellNos, spatial = FALSE))
xyData<- as.matrix(gXY)} else {xyData <- data}
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
## Need capture output to save hash key to a readme file
# rasterise tabular data
if (raster_object == TRUE){
tDat<- cbind(xyData, tempD)
if (ncol(tDat) > 4){
rasterOuts<- stack()
for (z in 4:ncol(tDat)){
rasterOuts<- stack(rasterOuts, rasterFromXYZ(tDat[,c(1,2,z)]))}
} else {
rasterOuts<- rasterFromXYZ(tDat[,c(1,2,4)])}
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_raster",stub, "_", hash.out, ".rds")
saveRDS(object = rasterOuts, file = nm2)
return(rasterOuts)} else {
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_",stub, "_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}}
point_detang<- detangles(data=xyData, tanglerInfo=detangler.dat, raster_object = FALSE, stub = "hv_fix")
tangled.origi
#rasters
raster_detang<- detangles(data=tangled.origi, tanglerInfo=detangler.dat, raster_object = TRUE, stub = "hv_fix")
plot(raster_detang[[1]])
pdat<- as.data.frame(point_detang)
coordinates(pdat)<- ~X + Y
plot(pdat, add=T)
point_detang
tangles.out
tangles.out[[1]]
class(tangles.out[[1]])
## detangles
# points
xyData<- as.matrix(tangles.out[[1]])
detangler.dat<- readRDS("detangler_5f47b108227d1b405b88b70a4abbcfe25c6563f8e4801ef7f5fae10d776143e8.rds")
str(detangler.dat)
point_detang<- detangles(data=xyData, tanglerInfo=detangler.dat, raster_object = FALSE, stub = "hv_fix")
#rasters
raster_detang<- detangles(data=tangled.origi, tanglerInfo=detangler.dat, raster_object = TRUE, stub = "hv_fix")
plot(raster_detang[[1]])
pdat<- as.data.frame(point_detang)
coordinates(pdat)<- ~X + Y
plot(pdat, add=T)
## Tangle points then rasters
# plot original points
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
# tangler
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
detangler.dat<- readRDS("detangler_1465351c42949cc8db6d6d3e3f15e65a39211560207d4c12607aaafe7dfa8f1b.rds")
str(detangler.dat)
plot(xyData)
tangled.origi<- tangler(data = xyData, tanglerInfo = detangler.dat, raster_object = FALSE, stub = "hv1")
head(tangled.origi)
## test it out with raster data
library(raster)
data("hunterCovariates_sub")
str(hunterCovariates_sub)
raster_object<- hunterCovariates_sub
tangles.out<- tangles(data = hunterCovariates_sub, depth = 10, rasterdata = TRUE, raster_object = TRUE)
tangles.out
str(tangles.out)
#tangler
# tangler
data("hunterCovariates_sub")
str(hunterCovariates_sub)
detangler.dat<- readRDS("detangler_77f23ff80a5320acda37bd03085f9e91dfadce3a66ce955928cba757a1d17964.rds")
str(detangler.dat)
tangled.origi<- tangler(data = hunterCovariates_sub, tanglerInfo = detangler.dat, raster_object = TRUE, stub = "hv1")
tangled.origi
plot(tangled.origi[[1]])
## Tangle points then rasters
# plot original points
plot(hunterCovariates_sub[[1]])
plotxydat<- as.data.frame(xyData)
coordinates(plotxydat)<- ~ X + Y
plot(plotxydat,add=T)
