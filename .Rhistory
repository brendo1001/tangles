xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# join to covariates
tempD<- cbind(xyData, tempD)
head(tempD)
ras1<- rasterFromXYZ(tempD[,c(1,2,4)])
###############################
# rasterize points
###############################
r <- raster(ncols=36, nrows=18)
n <- 1000
set.seed(123)
x <- runif(n) * 360 - 180
y <- runif(n) * 180 - 90
xy <- cbind(x, y)
# get the (last) indices
r0 <- rasterize(xy, r)
r0
plot(r0)
# prensence/absensce (NA) (is there a point or not?)
r1 <- rasterize(xy, r, field=1)
# how many points?
r2 <- rasterize(xy, r, fun=function(x,...)length(x))
vals <- runif(n)
# sum of the values associated with the points
r3 <- rasterize(xy, r, vals, fun=sum)
plot(r3)
vals
xy
plot(r1)
plot(r2)
r
###############################
# rasterize points
###############################
r <- raster(ncols=36, nrows=18)
r
str(r)
r@extent
r@extent[1]
r@extent[1]<- 100
r
str(r)
min(tempD[,1])
max(tempD[,1])
options(digits=5)
## convert raster object to table format
tempD <- data.frame(cellNos = seq(1:ncell(raster_object)))
vals <- as.data.frame(getValues(raster_object))
tempD<- cbind(tempD, vals)
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(raster_object, cellNos, spatial = FALSE))
##
xyData<- as.matrix(gXY)
## do the spatial transfomrations
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# join to covariates
tempD<- cbind(xyData, tempD)
head(tempD)
min(tempD[,1])
max(tempD[,1])
min(tempD[,2])
max(tempD[,2])
r1<- hunterCovariates[[1]]
r1
crs(r1)
nrow(tempD)
r1@extent
r1@extent[1]
r1@extent[1]<- min(tempD[,1])
r1@extent[2]<- max(tempD[,1])
r1@extent[3]<- min(tempD[,2])
r1@extent[4]<- max(tempD[,2])
r1@extent[3]<- min(tempD[,2])
r1
plot(r1)
tangles<- function(xyData=NULL, depth=3){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_X<- function(xyData=NULL){
r.num<- sample(-999999:999999, 1)
xyData[,1]<- xyData[,1] + r.num
return(list(xyData, r.num))
}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Y<- function(xyData=NULL){
r.num<- sample(-999999:999999, 1)
xyData[,2]<- xyData[,2] + r.num
return(list(xyData, r.num))
}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XY<- function(xyData=NULL){
# pick a point at random from the dataset
row.sample<- sample(1:nrow(xyData),1)
origin.point<- xyData[row.sample,]
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
deg<- sample(1:359,1, replace = F) # choose a random orientation
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(list(xyData,origin.point,deg))
}
## END Step 3 (data rotation)
## letters and numbers randomisation
########################################## END internalised step functions
## randomise the sequence of steps with defined depth
step.random<- sample(1:3, depth, replace = T)
## cycle through the step sequence
s3.cnt<- 1
seq.mat<- matrix(NA, nrow = depth, ncol = 6)
for (i in 1:depth){
seq.step<- step.random[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_X(xyData = xyData)
# save outputs
xyData<- step1.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step1.out[[2]]}
# if step 2
if(seq.step == 2){
step2.out<- leap_Y(xyData = xyData)
# save outputs
xyData<- step2.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step2.out[[2]]}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XY(xyData = xyData)
# save outputs
xyData<- step3.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,3:4]<- step3.out[[2]]
seq.mat[i,5]<- step3.out[[3]]
seq.mat[i,6]<- s3.cnt
s3.cnt<- s3.cnt + 1}
}
seq.dat<- as.data.frame(seq.mat)
names(seq.dat)<- c("step", "leap_dist", "origin_X", "origin_Y", "degree", "s3_count")
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# generate a hash
hash.out<- digest(seq.dat ,"sha256") # first try
deTangler<- list(hash = hash.out, step_sequence= step.random, unpicker= seq.dat)
# write de-tangler to file
nm1<- paste0(getwd(), "/detangler_", hash.out, ".rds")
saveRDS(object = deTangler, file = nm1)
# write revised coordinates to file
nm2<- paste0(getwd(), "/tangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(list(xyData, deTangler))}
## test it out
setwd("/home/malone/Dropbox/2019/rmuddles/deIDent/")
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(xyData = xyData, depth = 3)
tangles.out
detangler.dat<- readRDS("detangler_94d5dc62251dc75932a791eda6b756b2d0b4400606375fc79adb13742c1c6365.rds")
str(detangler.dat)
tanglerInfo = detangler.dat
## convert raster object to table format
tempD <- data.frame(cellNos = seq(1:ncell(raster_object)))
vals <- as.data.frame(getValues(raster_object))
tempD<- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(raster_object, cellNos, spatial = FALSE))
##
xyData<- as.matrix(gXY)
## do the spatial transfomrations
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# join to covariates
tempD<- cbind(xyData, tempD)
head(tempD)
ras1<- rasterFromXYZ(tempD[,c(1,2,4)])
## convert raster object to table format
tempD <- data.frame(cellNos = seq(1:ncell(raster_object)))
vals <- as.data.frame(getValues(raster_object))
tempD<- cbind(tempD, vals)
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(raster_object, cellNos, spatial = FALSE))
##
xyData<- as.matrix(gXY)
## do the spatial transfomrations
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# join to covariates
tempD<- cbind(xyData, tempD)
head(tempD)
ras1<- rasterFromXYZ(tempD[,c(1,2,4)])
ras1<- rasterFromXYZ(tempD[,c(1,2,4)],digits=1)
tempD[1,1]-tempD[2,1]
plot(tempD[1:100,1:2])
plot(tempD[1:500,1:2])
plot(tempD[1:5000,1:2])
plot(tempD[1:5000,1:2],cex=0.2)
plot(tempD[1:5000,1:2],cex=0.1)
plot(tempD[,1:2],cex=0.1)
tempD[5,1]-tempD[6,1]
tempD[10,1]-tempD[11,1]
## convert raster object to table format
tempD <- data.frame(cellNos = seq(1:ncell(raster_object)))
vals <- as.data.frame(getValues(raster_object))
tempD<- cbind(tempD, vals)
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(raster_object, cellNos, spatial = FALSE))
head(gXY)
##
xyData<- as.matrix(gXY)
tangles.out<- tangles(xyData = xyData, depth = 3)
tangles.out
str(tangles.out)
head(tangles.out[[1]])
library(ithir);library(digest);library(raster)
data("hunterCovariates")
raster_object<- hunterCovariates
raster_object
## convert raster object to table format
tempD <- data.frame(cellNos = seq(1:ncell(raster_object)))
vals <- as.data.frame(getValues(raster_object))
tempD<- cbind(tempD, vals)
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(raster_object, cellNos, spatial = FALSE))
##
xyData<- as.matrix(gXY)
tangles<- function(xyData=NULL, depth=3){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_X<- function(xyData=NULL){
r.num<- sample(-999999:999999, 1)
xyData[,1]<- xyData[,1] + r.num
return(list(xyData, r.num))
}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Y<- function(xyData=NULL){
r.num<- sample(-999999:999999, 1)
xyData[,2]<- xyData[,2] + r.num
return(list(xyData, r.num))
}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XY<- function(xyData=NULL){
# pick a point at random from the dataset
row.sample<- sample(1:nrow(xyData),1)
origin.point<- xyData[row.sample,]
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
deg<- sample(1:359,1, replace = F) # choose a random orientation
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(list(xyData,origin.point,deg))
}
## END Step 3 (data rotation)
## letters and numbers randomisation
########################################## END internalised step functions
## randomise the sequence of steps with defined depth
step.random<- sample(1:3, depth, replace = T)
## cycle through the step sequence
s3.cnt<- 1
seq.mat<- matrix(NA, nrow = depth, ncol = 6)
for (i in 1:depth){
seq.step<- step.random[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_X(xyData = xyData)
# save outputs
xyData<- step1.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step1.out[[2]]}
# if step 2
if(seq.step == 2){
step2.out<- leap_Y(xyData = xyData)
# save outputs
xyData<- step2.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,2]<- step2.out[[2]]}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XY(xyData = xyData)
# save outputs
xyData<- step3.out[[1]]
seq.mat[i,1]<- seq.step
seq.mat[i,3:4]<- step3.out[[2]]
seq.mat[i,5]<- step3.out[[3]]
seq.mat[i,6]<- s3.cnt
s3.cnt<- s3.cnt + 1}
}
seq.dat<- as.data.frame(seq.mat)
names(seq.dat)<- c("step", "leap_dist", "origin_X", "origin_Y", "degree", "s3_count")
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
# generate a hash
hash.out<- digest(seq.dat ,"sha256") # first try
deTangler<- list(hash = hash.out, step_sequence= step.random, unpicker= seq.dat)
# write de-tangler to file
nm1<- paste0(getwd(), "/detangler_", hash.out, ".rds")
saveRDS(object = deTangler, file = nm1)
# write revised coordinates to file
nm2<- paste0(getwd(), "/tangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(list(xyData, deTangler))}
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
tangles.out<- tangles(xyData = xyData, depth = 3)
head(tangles.out[[1]])
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
detangles<- function(xyData=NULL, tanglerInfo=NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
## Need capture output to save hash key to a readme file
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
plot(dat.xy)
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(xyData = xyData, depth = 25)
tangles.out[[2]]
tangles.out<- tangles(xyData = xyData, depth = 3)
tangles.out
tangles.out[[2]`hash`]
tangles.out[[2]$`hash`]
str(tangles.out)
tangles.out[[2]$hash
tangles.out[[2]hash
tangles.out[[2]
]
tangles.out[[2]][[1]]
##detangles
tangled.dat<- readRDS("tangledXY_ca24e91b5a6d8ea35abd660692413d7a303e3fefadf20ca9b499f5a7490e6180.rds")
detangler.dat<- readRDS("detangler_ca24e91b5a6d8ea35abd660692413d7a303e3fefadf20ca9b499f5a7490e6180.rds")
str(detangler.dat)
head(tangled.dat)
head(xyData)
xyData[1,1]-xyData[2,1]
tangled.dat[1,1]-tangled.dat[2,1]
plot(hunterCovariates)
plot(hunterCovariates[[1]])
point(xyData)
points(xyData)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
plot(dat.xy)
plot(hunterCovariates[[1]])
plot(dat.xy, add=T)
plot(hunterCovariates[[1]])
plot(hunterCovariates[[1]])
points(xyData)
xyData
data("hunterCovariates_sub")
plot(hunterCovariates_sub[[1]])
points(xyData)
