## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
#origin point
origin.point<- xyData[row.sample,]
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(xyData = xyData, depth = 6)
##detangles
tangled.dat<- readRDS("detangler_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
##detangles
tangled.dat<- readRDS("tangledXY_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
detangler.dat<- readRDS("detangler_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
str(detangler.dat)
origXY<- detangles(xyData = tangled.dat, tanglerInfo = detangler.dat)
origXY<- detangles(xyData = tangled.dat, tanglerInfo = detangler.dat)
detangles<- function(xyData=NULL, tanglerInfo=NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
origXY<- detangles(xyData = tangled.dat, tanglerInfo = detangler.dat)
origXY<- detangles(xyData = as.matrix(tangled.dat), tanglerInfo = detangler.dat)
as.matrix(tangled.dat)
plot(tangled.dat)
origXY<- detangles(xyData = as.matrix(tangled.dat), tanglerInfo = detangler.dat)
tanglerInfo
xyData = as.matrix(tangled.dat)
i
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
jp
seq.step
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
step1.out
detangles<- function(xyData=NULL, tanglerInfo=NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
##detangles
tangled.dat<- readRDS("tangledXY_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
detangler.dat<- readRDS("detangler_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
str(detangler.dat)
origXY<- detangles(xyData = as.matrix(tangled.dat), tanglerInfo = detangler.dat)
origXY
plot(origXY)
points(dat.xy, col="red")
detangles<- function(xyData=NULL, tanglerInfo=NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
source('Z:/Dropbox/2019/rmuddles/deIDent/tangles.R')
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(xyData = xyData, depth = 6)
##detangles
tangled.dat<- readRDS("tangledXY_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
detangler.dat<- readRDS("detangler_22721ab8f73c197c9c60cf02da51de07f5f27ff20dda819dd7a1578fceed7423.rds")
xyData<- as.matrix(tangled.dat)
##detangles
tangled.dat<- readRDS("tangledXY_10c81ab266a0a34c90fac30f5c77090247ac9dcd1286ecb267682219c3671e92.rds")
detangler.dat<- readRDS("detangler_10c81ab266a0a34c90fac30f5c77090247ac9dcd1286ecb267682219c3671e92.rds")
str(detangler.dat)
xyData<- as.matrix(tangled.dat)
origXY<- detangles(xyData = , tanglerInfo = detangler.dat)
xyData<- as.matrix(tangled.dat)
origXY<- detangles(xyData = xyData, tanglerInfo = detangler.dat)
# test
plot(dat.xy, cex=0.25)
points(origXY, col="red")
source('Z:/Dropbox/2019/rmuddles/deIDent/tangles.R')
detangles<- function(xyData=NULL, tanglerInfo=NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xba<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] - r.num
return(xyData)}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yba<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] - r.num
return(xyData)}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYba<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
#origin point
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
bdeg<- 360 - deg  # choose a random orientation
theta = (bdeg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)}
## END Step 3 (data rotation)
########################################## END internalised step functions
## cycle through the step sequence
for (i in 1:nrow(tanglerInfo$unpicker)){
jp<- nrow(tanglerInfo$unpicker) - (i-1)
seq.step<- tanglerInfo$unpicker$step[jp]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xba(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yba(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[jp])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYba(xyData = xyData, deg = tanglerInfo$unpicker$degree[jp], origin.point = c(tanglerInfo$unpicker$origin_X[jp], tanglerInfo$unpicker$origin_Y[jp]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/detangledXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
## test it out
setwd("Z:/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
tangles.out<- tangles(xyData = xyData, depth = 25)
##detangles
tangled.dat<- readRDS("tangledXY_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
detangler.dat<- readRDS("detangler_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
str(detangler.dat)
xyData<- as.matrix(tangled.dat)
plot(xyData)
plot(dat.xy)
##detangles
tangled.dat<- readRDS("tangledXY_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
detangler.dat<- readRDS("detangler_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
str(detangler.dat)
xyData<- as.matrix(tangled.dat)
plot(xyData)
origXY<- detangles(xyData = xyData, tanglerInfo = detangler.dat)
# test
plot(dat.xy, cex=0.25)
points(origXY, col="red")
detangler.dat<- readRDS("detangler_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
str(detangler.dat)
plot(xyData)
## test it out
setwd("/home/malone/Dropbox/2019/rmuddles/deIDent/")
library(ithir);library(digest)
data("HV_subsoilpH")
str(HV_subsoilpH)
dat.xy<- HV_subsoilpH[,1:2]
xyData<- as.matrix(dat.xy)
detangler.dat<- readRDS("detangler_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
str(detangler.dat)
plot(xyData)
tangled.origi<- tangler(xyData = xyData, tanglerInfo = detangler.dat)
tangler<- function(xyData=NULL, tanglerInfo = NULL){
###### Internalised Step Functions
## Step 1 (shifting X)
leap_Xr<- function(xyData=NULL, r.num=NULL){
xyData[,1]<- xyData[,1] + r.num
return(xyData)
}
## End Step 1 (shifting X)
## Step 2 (shifting Y)
leap_Yr<- function(xyData=NULL, r.num=NULL){
xyData[,2]<- xyData[,2] + r.num
return(xyData)
}
## End Step 2 (shifting Y)
## Step 3 (data rotation)
rotate_XYr<- function(xyData=NULL, deg=NULL, origin.point=NULL){
## Prep data for rotation
x<- t(xyData[,1])
y<- t(xyData[,2])
v = rbind(x,y)
x_center = origin.point[1]
y_center = origin.point[2]
#create a matrix which will be used later in calculations
center <-  v
center[1,]<- as.matrix(x_center)
center[2,]<- as.matrix(y_center)
theta = (deg * pi)/180      # express in radians
R = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow=2)
# do the rotation...
s = v - center    # shift points in the plane so that the center of rotation is at the origin
so = R%*%s           # apply the rotation about the origin
vo = so + center   # shift again so the origin goes back to the desired center of rotation
# pick out the vectors of rotated x- and y-data
xyData<- cbind(vo[1,], vo[2,])
return(xyData)
}
## END Step 3 (data rotation)
########################################## END internalised step functions
for (i in 1:nrow(tanglerInfo$unpicker)){
seq.step<- tanglerInfo$unpicker$step[i]
# if step 1
if(seq.step == 1){
step1.out<- leap_Xr(xyData = xyData , r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step1.out}
# if step 2
if(seq.step == 2){
step2.out<- leap_Yr(xyData = xyData, r.num = tanglerInfo$unpicker$leap_dist[i])
# save outputs
xyData<- step2.out}
# if step 3
if(seq.step == 3){
step3.out<- rotate_XYr(xyData = xyData, deg = tanglerInfo$unpicker$degree[i], origin.point = c(tanglerInfo$unpicker$origin_X[i], tanglerInfo$unpicker$origin_Y[i]))
# save outputs
xyData<- step3.out}}
xyData<- as.data.frame(xyData)
names(xyData)<- c("X", "Y")
hash.out<- tanglerInfo$hash
# write revised coordinates to file
nm2<- paste0(getwd(), "/tanglerXY_", hash.out, ".rds")
saveRDS(object = xyData, file = nm2)
return(xyData)}
tangled.origi<- tangler(xyData = xyData, tanglerInfo = detangler.dat)
tangled.origi
#test
t.dat<- readRDS("tangledXY_7cf86c89cca6207f3eff300e550d87fea09b076d090345edd77b8d8fc7fb0aaa.rds")
plot(t.dat, cex=0.23)
points(tangled.origi, col="red")
